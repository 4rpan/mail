import { type } from "arktype";

/**
 * Error Scema JSON payload
 */
export const ErrorValue = type({
  success: "false",
  "message?": "string",
  "errors?": "string[]",
});

/**
 * Error Scema JSON payload base
 */
export const SuccessValue = type("<T>", {
  success: "true",
  "message?": "string",
  data: "T",
});

/**
 * Mail Body Schema
 */
export const MailBody = type({
  /**
   * looks like traditional (SMTP) email addresses
   * `sender@server.tld`
   */
  from: "string.email",
  /**
   * relays mail to moh or even forward to SMTP server if moh enpoint is unreachable;
   * `reciever@server.tld`
   */
  to: "string.email",
  /**
   * unix second
   */
  "at?": "string.date.iso",
  /**
   * unencrypted title
   */
  subject: "string",
  /**
   * `id` (mail id) generated by sender for the recipient's server
   */
  id: "string.alphanumeric",
  /**
   * id provided by sender for reciever (generated by reciever or generated with a specified pattern)
   * eg, `mail://reciever@server.tld/ref?payment108`
   */
  "ref?": "string.alphanumeric",
  /**
   * ideally mandatory
   * but if sending from an smtp address, it can be blank, then server encrypts & store encrypted content value.
   * signature uses concatenated 'from', 'at', 'subject' as message
   * if valid moh address exists, it'll throw an error for "invalid signature"
   */
  "signature?": "string.base64",
  /**
   * encrypted content (base64 data uri with content type & charset)
   */
  content: "string.base64.url",
  /**
   * meta fields
   * eg, { threadId: 123, replyingTo: xyz }
   */
  "metadata?": "Record<string, unknown>",
});

/**
 * Important shared schemas
 * 
 * @example
 * ```ts
 * import { ErrorValue, SuccessValue } from "@arpan/mail/types";
 *  const res = SuccessValue({
      ids: "string[]",
    }).or(ErrorValue)
 * ```
 * @module types
 */
export default { SuccessValue, ErrorValue, MailBody };
